<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Omicron-Spirograph by VideoAlchemy</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css">
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>
      <div id="header">
        <nav>
          <li class="fork"><a href="https://github.com/VideoAlchemy/OmiCron-SpiroGraph">View On GitHub</a></li>
          <li class="downloads"><a href="https://github.com/VideoAlchemy/OmiCron-SpiroGraph/zipball/master">ZIP</a></li>
          <li class="downloads"><a href="https://github.com/VideoAlchemy/OmiCron-SpiroGraph/tarball/master">TAR</a></li>
          <li class="title">DOWNLOADS</li>
        </nav>
      </div><!-- end header -->

    <div class="wrapper">

      <section>
        <div id="title">
          <h1>Omicron-Spirograph</h1>
          <p>A UI framework for precisely creating, controlling, and compiling particle system configurations.</p>
          <hr>
          <span class="credits left">Project maintained by <a href="https://github.com/VideoAlchemy">VideoAlchemy</a></span>
          <span class="credits right">Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></span>
        </div>

        <h3>
<a name="from-spirograph-to-particle-system-framework" class="anchor" href="#from-spirograph-to-particle-system-framework"><span class="octicon octicon-link"></span></a>From Spirograph to Particle System Framework:</h3>

<ul>
<li>what started as a responsive flow-field of illuminated particles designed for the Calistoga Springs event Luminescent Playground (Sept 21-23, 2013) is now a solid tool for configuring particle systems.</li>
<li>The documentation contained in this README reflects this transition from single project to underlying framework.</li>
<li>Requires name change since original names no longer apply to the current project (OmiCron-Spirograph and Juggling Molecules).  Potential replacements:

<ul>
<li>FlowConfig</li>
<li>LuxDust</li>
<li>suggestions?</li>
</ul>
</li>
</ul><h3>
<a name="documentation" class="anchor" href="#documentation"><span class="octicon octicon-link"></span></a>Documentation:</h3>

<ul>
<li><a href="http://www.flickr.com/photos/jaycody9/sets/72157635574816773/">images of user interaction, pre-event install, screenshots and diagrams from development </a></li>
<li><a href="http://youtu.be/oneMByLSmEg">vids (screen recordings and tests)</a></li>
</ul><h3>
<a name="juggling-molecules" class="anchor" href="#juggling-molecules"><span class="octicon octicon-link"></span></a>Juggling Molecules</h3>

<ul>
<li>A responsive flow-field of illuminated particles designed for the Calistoga Springs' festival Luminescent Playground held Sept 20-23, 2013</li>
<li>the interface is a combination of gesture control supplied by a dancer's movement, and knob turning by participants using controls on an iPad.</li>
<li>The design originally called for the use of the podium sized OmiCron Interface, which would sit somewhere on the edge of the dance floor enticing users with its 7 large knobs and 4 glowing buttons.<br>
</li>
<li>The original design also called for an iPad interface to control the remain 50 variables not intended for public consumption.</li>
<li>The OmiCron controls were scrapped, and we ended up designing the iPad controls for public use.  For the event, we attached the iPad to a clamp and attached the clamp to a tripod which presented the iPad for the user at about chest height. To help users deal with the overwhelming number of variables, we created 100 presets, many pre-populated with configurations prior to the event. </li>
<li>Original plans also included an semi-autonomous 3D spirograph pattern called a SpiroLight.  We were interested in expressing lifelike spontaneous behavior, something that would act as if it were aware of the dancers and their movements.  The documentation that follows includes ideas and strategies for this feature.</li>
</ul><h3>
<a name="hardware-and-software-required" class="anchor" href="#hardware-and-software-required"><span class="octicon octicon-link"></span></a>Hardware and Software required:</h3>

<ul>
<li>Mac Mini</li>
<li>Kinect Depth Sensor</li>
<li>Processing 2.0.3</li>
<li>SimpleOpenNI 1.96</li>
<li>iPad running TouchOSC</li>
<li>Projector</li>
<li>Rigging gear, power cables, VGA cables</li>
<li>Rubbermaid container to house the gear and keep it dry (outdoor event and it did rain)</li>
<li>150 inch Portable rear projection screen</li>
<li>[Deprecated]:

<ul>
<li><a href="http://www.flickr.com/photos/jaycody9/sets/72157632699562712/">OmiCron The Interface</a></li>
</ul>
</li>
</ul><h3>
<a name="interactions" class="anchor" href="#interactions"><span class="octicon octicon-link"></span></a>Interactions:</h3>

<ol>
<li>Dancer with OmiCron Controller</li>
<li>Dancer with SpiroLight</li>
<li>Dancer with Particles</li>
<li>Particles with SpiroLight

<ul>
<li>Autonomous Vehicles AVOID OR PURSUE SpiroLight (Omicron Control)</li>
<li>When emerging from and avoiding spiroLight, particles steer toward Dancer</li>
<li>When emerging from and avoiding dancer, particles steer toward Spirolight.  When within range of outer most arm, particles accelerate like additive flashes of light and disappear inside spirolight.  Born again from Dancer's movement (optical flow)</li>
</ul>
</li>
<li>OmiCron with SpiroLight</li>
<li>OmiCron with Particles</li>
</ol><h3>
<a name="omicron-map-controls-to-spirolight" class="anchor" href="#omicron-map-controls-to-spirolight"><span class="octicon octicon-link"></span></a>OmiCron: Map Controls to SpiroLight:</h3>

<ul>
<li>[] Button shuffles ratios for specified tier

<ul>
<li>where on the circle is arm connected? (make that a Perlin Noise function where button down progresses through perlin noise for all variables.</li>
</ul>
</li>
<li>[] First tier Red knobs control overall size of spiroLight, mass, and steering ability toward target.  Mass gets bigger, slower it moves, the larger the circle, the larger the entire spiroLight  (as opposed to following closest point, which changes the size of spiroLight because of perspective being further away, but does not change the mass or the periods)</li>
<li>[] Knobs control Magnitude of all the vectors, while buttons control location within each variables range</li>
<li>[] Snap Button = Reverse Emitter Location from Tier 3 to Dancer.

<ul>
<li>when Emitter Origin is in SpiroLight, particles flock to Dancer</li>
<li>Particles follow path along edges up dancer and out of spirolight</li>
</ul>
</li>
<li>[] Tier 1 = Red, Tier 2 = Green, Tier 3 = Blue</li>
<li>[] Each of the 3 omiCron buttons will change ratios (angular velocities, magnitude) for that color

<ul>
<li>eg Green Line From Tier 1 to Tier 2, and Green Line from Tier 2 to Tier 3 are:<br><ul>
<li>1:1 in length, 1:1 in angular velocity, and are IN PHASE </li>
<li>1:2 in length, 1:-2 in angular velocity, and are out of phase by 90degrees</li>
<li>1:sqrt2 in length, 1:1.618 in angular velocity, and are out of phase by 180</li>
</ul>
</li>
</ul>
</li>
<li>[] Knobs: Red(Left and Right) Green(L,R), Blue(L,R) control the rotational velocity and distance to next teir.</li>
<li>[] Ohmite Knob controls the parameters of the flow field (somehow) and/or z-axis rotation</li>
<li>[] Add remainder of tier 2 and 3</li>
<li>Omicrons controls are mapped to the parameters of a spirograph-like pattern projected on a rear projection screen.  Dancers control the location of the pattern by way of the closest point in a 3D point cloud (ie the pattern will follow their hand if their hand contains the point closest to the Kinect sensor.  Dancers can also interact with a particle system whose behavior is controlled by a depth informed flow field.  Dancer's distance and velocity determine the behavior of the particles.</li>
<li>Create SpiroLight structure from Fractal Recursion??

<ul>
<li>
<a href="https://vimeo.com/64424402">Fractal Recursion  |  Shiffman</a> </li>
</ul>
</li>
<li>
<strong>OmiCron Structure:</strong>

<ul>
<li>[] Add extra lights to the bottom of OmiCron (since the device WILL be in an open field)

<ul>
<li>[] use a second Arduino??  Yes.</li>
</ul>
</li>
<li>[] Add Handles</li>
<li>[] Bring extra batteries</li>
<li>[] bring usb mouse and keyboard just in case</li>
<li>[] bring Blue Tooth</li>
</ul>
</li>
</ul><h3>
<a name="spirolight" class="anchor" href="#spirolight"><span class="octicon octicon-link"></span></a>SpiroLight:</h3>

<ul>
<li>
<strong>SpiroLight Forces:</strong>

<ul>
<li>AstralLines (rotating arms):

<ul>
<li>arm length mapped to Velocity's Magnitude such that arms stretch when accelerating and shrink when decelerating (or vice versa).</li>
<li>Perlin Noise the mapping of acceleration to arm length such that perlin noise wanders along a continuum of MaxSpeed = MaxLength AND MaxSpeed = Min Length </li>
<li>Arm Rotation to Perlin Noise</li>
<li>Add the SCALE function to simulate 3D</li>
<li>Arm pivot point on circle wanders</li>
</ul>
</li>
<li>Tier 1 Location Vectors have 4 control modes: (4 types of Forces that act upon primary location vector)

<ol>
<li>TEST MODE:  Follow Mouse (ie sub(location, mouse))</li>
<li>DANCER MODE:<br><ul>
<li>Follow/ PursueClosest Point in Point Cloud (controlled by dancer)</li>
<li>Evade closest point Dancer</li>
</ul>
</li>
<li>NULL USER MODE:  Perlin Noise (which can be used to inform all the arms and rotations)</li>
<li>OMICRON ONLY MODE: (or FP-13 Mode) or Touch OSC:  No Kinect Attached, no dancer.  Forces mapped to RedKnob Left and Right for (x,y)</li>
</ol>
</li>
</ul>
</li>
<li>
<p><strong>SpiroLight with FlowField.</strong>  </p>

<ul>
<li>Instead of constant angular velocity, SpiroLight joints can respond to the Flow Field with their own steering force.  The joints are vehicles that check in a ask, 'does the flow field bellow have information for me?  If not, then keep steady pace, otherwise, use flow field as desired velocity'.  Everytime spirolight sweeps over the dancer, the movements will adjust.  Or the colors will change to show the outline of the body.  If assign color variation to optical flow and sillouette, then the resulting blendMode(ADD) would be sufficient to change all the underlying pixels, effectively showing the dancers body.</li>
</ul>
</li>
<li>
<p><strong>SpiroLight Parameters and Controls:</strong></p>

<ul>
<li>
<p>Inner sphere of 3D Hypotrochoid:</p>

<ul>
<li>diameter -&gt; User-N's distance from Kinect </li>
<li>velocity -&gt; informed by velocity, location, and gravitational pull (determined by mass (from diameter) of User-N's center of gravity

<ul>
<li>use Center of Gravity velocity to inform direction and speed of ball rolling inside of sphere of a 3D Hypotrochoid</li>
</ul>
</li>
<li>location of traced point in center sphere:

<ul>
<li>informed by Omicron controls OR</li>
<li>set center of gravity to be an xyz point inside a ball.</li>
</ul>
</li>
<li>color and weight of traced point -&gt; Omicron</li>
</ul>
</li>
<li>
<p>Outer Sphere of 3D Hypotrochoid:</p>

<ul>
<li>diameter -&gt; distance between User-N's center of gravity and body part furthest away from User-N's center of gravity</li>
<li>location -&gt; follows User-N</li>
</ul>
</li>
<li>
<p>Parameter Options: </p>

<ul>
<li>map the traced point to the corner of an Emblem (Snaps image) such that each of 3 users control one corner of an image with their individually controlled  nested sphere. </li>
<li>Make each User's center of gravity a single cusp in an n-cusp hypocycloid.

<ul>
<li><a href="http://demonstrations.wolfram.com/EpicycloidsFromAnEnvelopeOfLines/">http://demonstrations.wolfram.com/EpicycloidsFromAnEnvelopeOfLines/</a></li>
</ul>
</li>
<li>Spirolight parameters effected by the presence of other Spirolights; creates interweaving patterns.  </li>
<li>line thickness controlled by Kinect depth info</li>
<li>Traced line is occluded when it passes behind the User!!! user appears to be inside the Spirolight. </li>
<li>If user occludes the animation based on depth, then the outline created by User's body may br enough to depict the human form in negative space. Thus, no need for extra pixels. </li>
<li>Each User gets their own Spirolight (up to 3)</li>
<li>Create a 3-cusp epicycloid that remains 3-cusp while the distance between the cusps change (i.e., each cusp is the center of a moving body).  What other variables would have to change?</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Spirograph Definitions:</strong></p>

<ul>
<li>
<strong>Hypocycloids:</strong>

<ul>
<li><a href="http://mathworld.wolfram.com/Hypocycloid.html">http://mathworld.wolfram.com/Hypocycloid.html</a></li>
<li>Coin inside a ring; tracing a point on circumference of coin</li>
<li>An n-cusped hypocycloid has radiusA / radiusB = n.

<ul>
<li>Thus, a 5 pointed star has is a hypocycloid whose ring's radius is 5x the radius of the coin inside.</li>
</ul>
</li>
</ul>
</li>
<li>
<strong>Hypotrochoids:</strong>

<ul>
<li><a href="http://mathworld.wolfram.com/Hypotrochoid.html">http://mathworld.wolfram.com/Hypotrochoid.html</a></li>
<li>Coin inside a ring; tracing a point either inside or outside the perimeter of the coin</li>
</ul>
</li>
<li>
<strong>Epicycloids:</strong>

<ul>
<li><a href="http://mathworld.wolfram.com/Epicycloid.html">http://mathworld.wolfram.com/Epicycloid.html</a></li>
<li>Coin outside a ring; tracing a point on circumference of coin</li>
</ul>
</li>
<li>
<strong>Epitrochoids:</strong>

<ul>
<li><a href="http://mathworld.wolfram.com/Epitrochoid.html">http://mathworld.wolfram.com/Epitrochoid.html</a></li>
<li>Coin outside of ring; tracing a point either inside or outside the perimeter of coin</li>
</ul>
</li>
</ul>
</li>
</ul><h3>
<a name="spirolight--dancer" class="anchor" href="#spirolight--dancer"><span class="octicon octicon-link"></span></a>SpiroLight + Dancer:</h3>

<ul>
<li>
<strong>Specific Arms Always remain in contact with the DANCER and EDGE DETECT PATH FOLLOW.</strong><br><ul>
<li>
<strong>arrives and path follows along the edge of dancer's body with one of it's arms (or 2)!!</strong>  The SpiroLight follows the dancer and when it arrives, it's arms lock on to the edges and path follow.  Could cover and encircle the dancer like an octopus.  OR it grows NEW arms that remain in constant contact with user as the rest of the SpiroLight floats around.  Instead of harmonic monition, the arm follows the outline of the user.  see PATHFOLLOWING using the DOT PRODUCT</li>
<li>Some parts of the SpiroLight seek the dancer and some parts evade the dancer, so the thing is constantly investigating AND keeping it's distance.  If the Tier 1 Location Vector brings spiro closer to dancer, then arms that are repelled with flock together and move away while arms that are attracted will get closer.

<ul>
<li>AND the closer the arm, the greater the connetion, the brighter.</li>
<li>Whichever arm is path following along body will have perlin noise generated organic branching.</li>
</ul>
</li>
<li>AND Particle System coming from dancer ALWAYS remains in contact with spiroLight</li>
<li>where spiroLight is attracted to some point in the flow field that also guides the particles coming from Dancer</li>
</ul>
</li>
<li>
<strong>Dancer's Movement Also Affects Size and Brightness of SpiroLight</strong>

<ul>
<li>Use the Frame Differencing already used to inform the particle system</li>
<li>The same threshold velocity which triggers particles also brightens and expands the SpiroLight</li>
</ul>
</li>
</ul><h3>
<a name="optical-flow--kinect--dancer" class="anchor" href="#optical-flow--kinect--dancer"><span class="octicon octicon-link"></span></a>Optical Flow:  (Kinect + Dancer)</h3>

<ul>
<li>
<p><strong>Using Optical Flow:</strong></p>

<ul>
<li>with change in depth, not just change in frame!!!  Frame differencing in the z-axis!!**<br>
</li>
<li>Frame AND GreyScale Differencing for Depth Changes that are not along the x,y, but are instead, back and forth from the sensor.</li>
<li>[] RealTime 3D Optical Flow on a point cloud (color = point velocity; or color denotes movement direction and alpha denotes point velocity)</li>
<li>[] If movement &gt; threshold, calc magnitude and orientation of gradient, </li>
<li>If movement &gt; threshold, generate particle whose color equals the color of reference image and whose velocity is informed by the flow field.</li>
<li>
<strong>Color Code the Optical Flow</strong>

<ul>
<li>see the UCF Computer Vision lect at minute 4.  Movement left to right right to left are different colors.<br>
</li>
<li>Method is known as color coding vectors when velocity is mapped to the color intensity</li>
</ul>
</li>
<li>Use Optical FLow to create Motion Based Segmentation (show me only what's moving)</li>
<li>Brightness Constancy Assumption f(x,y,z) = f(x + dx, y + dy, t + dt)</li>
</ul>
</li>
<li>
<p><strong>Examples of Optical FLow:</strong></p>

<ul>
<li><a href="http://www.youtube.com/watch?v=2xs0fcmgKC0">Optical Flow Field + FLocking + Reference Image  |  YouTube</a></li>
<li><a href="http://www.youtube.com/watch?v=Edl6aWL1pjo">Optical Flow Field - handForce affects an object's velocity  |  YouTube</a></li>
<li><a href="http://www.youtube.com/watch?v=qhoC-YetpnM">Structure From Motion Using Optical Flow  |  Shows Image, Smoothed Image, MotionVectors  YouTube</a></li>
<li><a href="http://www.youtube.com/watch?v=5VyLAH8BhF8">UCF Computer Vision lect.6 Optical Flow</a></li>
<li>
<a href="http://dasl.mem.drexel.edu/%7EnoahKuntz/openCVTut9.html">OpenCV Optical Flow Tutorial for the Lucas-Kanade Algorithm</a>

<ul>
<li>The LK tracker uses three assumptions, brightness constancy between the same pixels from one frame to the next, small movements between frames (requiring image pyramids to track larger movements), and spatial coherence, thats points near each other are on the same surface. Then the basic concept of the tracker is to estimate the velocity of a moving pixel by the ratio of the derivative of the intensity over time divided by the derivative of the intensity over space. </li>
</ul>
</li>
<li><a href="http://www.cs.toronto.edu/pub/jepson/teaching/vision/2503/opticalFlow.pdf">Optical FLow Estimation Tutorial  |  pdf</a></li>
<li><a href="http://robots.stanford.edu/cs223b05/notes/CS%20223-B%20T1%20stavens_opencv_optical_flow.pdf">Computing Optical Flow with the OpenCV Library  |  Stavans, Stanford AI Lab</a></li>
<li><a href="http://www.cs.umd.edu/%7Edjacobs/CMSC426/OpticalFlow.pdf">Calculating Small Optical Flow  |  tutorial pdf</a></li>
<li><a href="http://graphics.berkeley.edu/papers/Tao-SAN-2012-05/">SimpleFlow: A Non-iterative, Sublinear Optical Flow Algorithm  |  Computer Graphics UC Berkeley</a></li>
<li><a href="http://en.wikipedia.org/wiki/Optical_flow">Optical FLow and the Methods of Calculating  |  wikipedia</a></li>
<li><a href="https://www.google.com/search?q=optical+flow&amp;safe=off&amp;tbm=isch&amp;tbo=u&amp;source=univ&amp;sa=X&amp;ei=3lcxUrneJeqWigLPxICADg&amp;ved=0CEUQsAQ&amp;biw=2128&amp;bih=1203&amp;sei=HFgxUsvZKOfgiALE9ICwBw#imgdii=_">Images of Optical FLow</a></li>
</ul>
</li>
<li>
<p><strong>Pseudo Code for Optical Flow:</strong></p>

<ul>
<li>Horn &amp; Shunck Optical Flow Algorithm

<ul>
<li>Brightness Constancy Assumption f(x,y,z) = f(x + dx, y + dy, t + dt)</li>
<li>Taylor Series</li>
</ul>
</li>
<li>Smooth Image with gausian blur</li>
<li>Compute derivative of filtered image</li>
<li>Find magnitude and orientation of gradient</li>
<li>Apply 'non-maximum' suppression</li>
</ul>
</li>
</ul><hr><ul>
<li>
<strong>Point Cloud:</strong>

<ul>
<li>We may keep the 2D world by pulling the 3D info from Kinect but projeting into 2D world.  Z-axis can convert to size instead of distance. </li>
<li>[] Make closest point in point cloud the desired target such that: </li>
<li>[] Create a Vector Field as function of depth</li>
<li>[] Build Library for Depth related Forces</li>
<li>[] In the abscence of movement (frame differencing &lt; threshold), then SpiroLight moves towards Dancer (b/c it seeks dancer's closest point to sensor)</li>
<li>[] Assign a movie to the depth greyScale such that changing grey plays movie back or forward.  Use this to mask out the dancer's white outline.</li>
</ul>
</li>
</ul><blockquote>
<p><code>steering force = desired velocity - current velocity</code></p>
</blockquote>

<ul>
<li>
<p><strong>Kinect-Projector Calibration</strong></p>

<ul>
<li><a href="http://youtu.be/FnulH8TrZVo">Kinect Projector Dance  |  YouTube Demo of the calibration tool</a></li>
<li><a href="http://www.youtube.com/watch?v=e_QdqYWWZJI">Interactive Projection Mapping Test  |  YouTube  LOOK FOR FEEDBACK LOOP at 2:20</a></li>
<li><a href="http://princemio.net/portfolio/kinect_projector_dance/">Kinect Calibration Tool and Tutorials |  by prince_MIO</a></li>
</ul>
</li>
<li>
<p><strong>Kinect Tutorials:</strong></p>

<ul>
<li><a href="http://vimeo.com/17087533">Kinect Depth Selection in Processing</a></li>
<li><a href="http://www.vimeo.com/groups/kinect">Kinect Interaction</a></li>
<li><a href="http://vimeo.com/17270320">Background Replacement with Kinect</a></li>
<li><a href="http://www.youtube.com/watch?v=z-aBUyrhcj0&amp;feature=related">Augmented Reality and Information Visualization</a></li>
</ul>
</li>
</ul><h3>
<a name="flowfield-calculation" class="anchor" href="#flowfield-calculation"><span class="octicon octicon-link"></span></a>FlowField Calculation:</h3>

<ul>
<li>accumulate forces from a variety of causes:  <strong>spiroLight-Field</strong>, <strong>dancer-Field</strong>, <strong>noise-Field</strong>

<ol>
<li>
<strong>(spiroLight-Field)</strong>  SpiroLight's Affect on the Flow Field:

<ul>
<li>affects the flowfield like iron flakes in a magnetic field.<br>
</li>
<li>Particles located further away follow a longer circuitous route. </li>
<li>Field Vector Magnitudes along the path to SpiroLight increase as their distance to Spirolight decreases (particles accelerate as they approach)</li>
</ul>
</li>
<li>
<strong>(dancer-Field)</strong>  Dancer's affect on the FlowField:

<ul>
<li>Dancers generate their own FlowField inside the Global Field.  Once calculated, the dancer's vector field is (ADDED?? SUBTRACTED?) to/from the SpiroLight Field </li>
<li>Flow Vectors within the boundary of the dancer's body align themselves with the magnitude and orientation of the body's depth gradients (pointing uphill)</li>
<li>Dancer's Flow Vectors</li>
</ul>
</li>
</ol>
</li>
<li>
<p>Future Fields: <strong>flowMap-Field</strong>, <strong>feedbackLoop-Field</strong>, <strong>windSensor-Field</strong></p>

<ul>
<li>
<p><strong>flowMap-Field</strong></p>

<ul>
<li>Use a reference image as a map to inform the field.  (ex. set direction according to brightness)</li>
<li>Examples:

<ul>
<li><a href="http://www.flickr.com/photos/jaycody9/sets/72157629880409223/">Flow Maps:  The Evolution of a Pattern Language  |  screenshots from a Processing sketch on flickr</a></li>
<li>[]</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>feedbackLoop-Field</strong></p>

<ul>
<li>feedback loop generated via a vector field?  probably not the best implementation.  A get() and set() feedback loop likely effective</li>
<li>however, a feedback layer can be produced that is specific to a certain kind of particle while ignoring other particles.  Perhaps particles generated in the negative diretion or a feeback pattern that only affects the frame differencing frames.</li>
</ul>
</li>
<li>
<p><strong>windSensor-Field</strong> </p>

<ul>
<li>or <strong>anemos-Field</strong>
</li>
<li>anemometer - a device used for measuring wind speed; from the Greek word ANEMOS, meaning wind</li>
<li>we'd use Gill Instrument's WindMaster 3-Axis Ultrasonic Wind Speed and Direction Sensor  <a href="http://www.gillinstruments.com/data/datasheets/WindMaster-Web-Datasheet.pdf">dataSheet</a>

<ul>
<li>provides wind speed and direction data</li>
<li>wind speed (0-45m/s and 0-65m/s)</li>
<li>0-359º wind direction range (no dead band)</li>
<li>wind direction (0-359º) data. </li>
<li>3-vector outputs (U, V, W), </li>
<li>data logging software</li>
<li>Speed of sound and sonic temperature outputs.</li>
<li>Optional analogue inputs and outputs are available with either 12 or 14 bit resolution.</li>
<li>This 3D sonic anemometer is ideally suited to the measurement of air turbulence around bridges, buildings, wind turbine sites, building ventilation control systems, meteorological and flux measurement sites.</li>
<li><a href="http://www.gillinstruments.com/data/datasheets/3_AXIS_web.pdf">3-Axis Wind Speed Sensor Brochure</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>How do we create one field from multiple fields?</p></li>
<li>[] flow field points to spirolight, unless located on dancer within min-max range</li>
<li>[] if dancer in field, then vector mag is depth and direction points to the edge.  once at the edge, particle moves toward spirolight according to background flow field</li>
<li>[] flow field vectors increase in magnitude as they approach spirolight such that particles accelerate toward the light</li>
<li>[] particle steering force and maxspeed change relative to their proximity to spirolight</li>
</ul><h3>
<a name="feedback-loop-as-pgraphic-layer" class="anchor" href="#feedback-loop-as-pgraphic-layer"><span class="octicon octicon-link"></span></a>Feedback Loop as PGraphic Layer</h3>

<ul>
<li>Frame Difference Seeds Feedback Loop

<ul>
<li>create new Pgraphic to hold only the frame differencing information such that currentPgraphic - previousPGraphic = differencePGraphic.  Then get() pixels from this layer and updatePixels with itself, creating a feedback loop</li>
<li>assign noise as velocity of Feedback Layer</li>
</ul>
</li>
<li>[] Create an array of PImages, each containing the previous frame to create a 5 sec sample of dancer + depth.  then rotate along the z-axis (see La Danse Kinect on vimeo).</li>
<li>[] How will CenterPiece-SpiroLight interact with the dancer's body?

<ul>
<li>blendMode(ADD)</li>
</ul>
</li>
<li>[] dancer is mask for reference image</li>
</ul><h3>
<a name="code" class="anchor" href="#code"><span class="octicon octicon-link"></span></a>Code:</h3>

<ul>
<li><p>Use createGraphics() to return a PGraphics object.  Unlike the main drawing surface, this surface retains transparency!  That means SpiroLight can fade without fading the particle system</p></li>
<li>
<p><strong>ToDo(Owen):</strong></p>

<ul>
<li>[] Particle System!  particle.lookup(PVector particleLocation); // will return a PVector force derived from the Flow Field state at that particle's location.  USE THE FORCE to inform acceleration to inform velocity to inform location.<br>
</li>
</ul>
</li>
<li><p><strong>ToDo(Installation):</strong></p></li>
</ul><h3>
<a name="code-snippets" class="anchor" href="#code-snippets"><span class="octicon octicon-link"></span></a>Code Snippets:</h3>

<pre><code></code></pre>
<ul>
<li><p>// with zero net force, object remains still or at constant velocity.  spiroLight object receives the force and hands it to the object's method applyForce(PVector force) where the force gets accumulated by acceleration with acceleration.add(force) (such that force informs acceleration, acceleration informs velocity, velocity informs location)</p></li>
<li><p>accumulate the net force (but only for any specific frame).  Update should end with acc.mag(0); to clear the forces that the acceleration vector has accumulated.</p></li>
</ul><pre><code>void applyForce (PVector force) {
    PVector newForceBasedOnObjectMass = PVector.div(force, mass); 
                // b/c more force required to move larger mass.
    acceleration.add(force);
}
void update() {
velocity.add(acceleration);
location.add(velocity);
}
</code></pre>

<ul>
<li><p>A simpler For-Loop Syntax for an Array:
<code>for (SpiroLight spiro : Spiros){}  // for every SpiroLight spiro in the array Spiros</code></p></li>
<li><p>Force = Mass X Acceleration</p></li>
<li><p>Acceleration = Force/Mass</p></li>
<li><p>What is the NORMAL force?  Always = 1 (in our processing world)</p></li>
<li><p>Friction Algorithm (what is mag and direction of friction (always against the direction of velocity)):  Friction Force = -1 X (unit direction velocity vector) X the NORMAL force X the coefficient of friction</p></li>
</ul><pre><code>PVector friction = velocity.get();  // get a copy of velocity vector
friction.normalize();  // normalize the copied velocity vector to get its direction
friction.mult(-1);   // now take the direction and put it in the opposite direction (because friction acts AGAINST the direction of velocity)
float coefficientOfFriction = .001;  // set the strength of the friction
friction.mult(coefficientOfFriction)  // the direction of friction and multiply by the magnitude set by the kind of substance causing the friction (the Coefficient of Friction)
</code></pre>

<ul>
<li>
<p><strong>Polar to Cartesian Cordinates</strong></p>

<ul>
<li>SOHCAHTOA</li>
<li>y = radius * sin(theta)</li>
<li>x = radius * cos(theta)</li>
</ul>
</li>
<li><p>The following statement will create a user defined function that will create Spirograph patterns:</p></li>
</ul><pre><code>spirograph = function (v_R, v_r, v_p, v_nRotations, s_color)
{
    t = vectorin(0, 0.05, 2 * pi * v_nRotations);:
    x = (v_R + v_r) * cos(t) + v_p * cos((v_R + v_r) * t / v_r);:
    y = (v_R + v_r)* sin(t) + v_p * sin((v_R + v_r) * t / v_r);:
    plot(x, y, s_color):
}
</code></pre>

<pre><code>- To see this function in action, execute the following statement:
</code></pre>

<blockquote>
<p><code>spirograph(53, -29, 40, 30, gray)</code></p>
</blockquote>

<h3>
<a name="examples" class="anchor" href="#examples"><span class="octicon octicon-link"></span></a>Examples:</h3>

<h4>
<a name="spirograph-examples" class="anchor" href="#spirograph-examples"><span class="octicon octicon-link"></span></a>Spirograph Examples:</h4>

<ul>
<li><a href="http://www.benjoffe.com/code/toys/spirograph">Spirograph Web App worth checking out</a></li>
<li><a href="https://vimeo.com/7757058">Epicycles On Epicycles, Cable Knots on Cable Knots | vimeo</a></li>
<li>
<a href="https://vimeo.com/2228788">The 3D Spirograph Project | vimeo</a>

<ul>
<li>The visual math of epicycloids. Nested rotational orbits produce emergent spiral designs in 3D.</li>
</ul>
</li>
<li><a href="https://vimeo.com/59028636">Vectors: Acceleration Towards the Mouse (Nature of Code) - Shiffman</a></li>
<li><a href="http://matheminutes.blogspot.com/2012/01/if-spirograph-were-3d.html">If Spirographs were 3D</a></li>
<li><a href="http://maxwelldemon.com/2010/01/14/spirographs-and-the-third-dimension/">Spirographs and the 3rd Dimensions | 3D printing</a></li>
<li><a href="http://wordsmith.org/%7Eanu/java/spirograph.html#display">Spirograph | Web App</a></li>
<li><a href="http://www.openprocessing.org/browse/?viewBy=tags&amp;tag=spirograph">Spirograph in Code | OpenProcessing website</a></li>
<li><a href="http://samjbrenner.com/notes/processing-spirograph/">Spirographs Explained | Sam Brenner from ITP</a></li>
<li><a href="http://dev.horemag.net/2008/03/03/spirograph-with-processing/">Simple Spirograph | Web App from Aquilax's Dev Blog</a></li>
<li><a href="http://mathiversity.com/Spirograph">Mathiversity | Spirograph Web App</a></li>
<li><a href="http://www.eddaardvark.co.uk/nc/sprog/index.html#x">Spirograph Web App</a></li>
</ul><h4>
<a name="flowfield-examples" class="anchor" href="#flowfield-examples"><span class="octicon octicon-link"></span></a>FlowField Examples:</h4>

<ul>
<li>
<a href="https://vimeo.com/153453#">Flocking in FlowField  |  Flight 404 on Vimeo</a>

<ul>
<li>
<a href="http://www.flight404.com/blog/?p=66">Flight 404 blog post about the Flocking Behaviors in a Flow Field</a>

<ul>
<li>In the original version, for some reason, I decided the best way to deal with the flowfield was to make a ton of vectors and stick them in the space. These vectors are stationary and only contain velocity information. I would use Perlin noise to adjust each vector’s velocity and just leave them there. Pretty much an invisible 3D array of floating arrows. I would then throw a bunch of objects in this 3D array and have each object check the nearest vector for its velocity information and apply this information to the objects own velocity.</li>
<li>Turns out, this was way more work than I needed. Instead, I should simply apply the Perlin noise data directly to my object’s velocity vectors and voila, done and done. And without needing to worry about placing thousands of vector arrows into a space that simply didnt need it. In a way, the Perlin noise data can represent an infinite space with an infinite number of vector arrows, and for cheap too.</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://vimeo.com/43802463">Flocking in 3D  |  Flight 404 for Eyeo 2012 Festival</a></li>
<li><a href="https://vimeo.com/43802127">Shockwave |  Flight 404</a></li>
<li><a href="http://www.youtube.com/watch?v=i_kCJe_VZ-E">Benjamin Moore Commercial  |  rotating paint buckets</a></li>
</ul><h4>
<a name="flowmaps-reference-images" class="anchor" href="#flowmaps-reference-images"><span class="octicon octicon-link"></span></a>FlowMaps, Reference Images:</h4>

<ul>
<li>[] add a method for </li>
</ul><h4>
<a name="theta-as-a-function-of-depth" class="anchor" href="#theta-as-a-function-of-depth"><span class="octicon octicon-link"></span></a>Theta as a function of Depth:</h4>

<h3>
<a name="future" class="anchor" href="#future"><span class="octicon octicon-link"></span></a>Future:</h3>

<ul>
<li>[] toxilib</li>
<li>
<p><a href="http://princemio.net/portfolio/flow-1-kinect-projector-dance/">Flow no.1 The Kinect Projector Dance</a></p>

<ul>
<li>Software Used for the project:

<ul>
<li>ofxOpenNI – created by gameoverhack – openNi wrapper to read captrued data from the kinect camera in realtime.</li>
<li>ofxCV – created by Kyle McDonald – fast openCV wrapper.</li>
<li>ofxFluidSolver – created by Memo Atken. After Years, it is still one of my favourite calculation models to illustrate continous flow of a dancer and graphics.</li>
<li>ofxUI – created by rezaali – having worked a lot in processing, i completly fell in love with this GUI library as it speeds up my tweaking processes. Its easy to use and fast to bind to variables.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Particles Create Shape -&gt; then use TEXTURE image:</strong></p>

<ul>
<li>currently particles from t1-tn create a line</li>
<li>use clusters of particles <strong>to form a shape</strong>
</li>
<li>then fill that shape with a texture randomly selected from an Emblem</li>
</ul>
</li>
<li>
<p><strong>FLOW MAPS</strong></p>

<ul>
<li>use SNAPS from OmiCron in addition to perlin noise field</li>
<li><strong>use RVL video archives to inform flow field</strong></li>
</ul>
</li>
</ul><hr><h3>
<a name="next-steps" class="anchor" href="#next-steps"><span class="octicon octicon-link"></span></a>Next Steps:</h3>

<ul>
<li>[] Setup OmiCron:

<ul>
<li>[x] Run Calibration with Processing.  Systems Check</li>
<li>[x] Tighten bolts on OmiCron pedestal</li>
<li>[x] review RotaDeva code for input flow.</li>
<li>[] Write the code that treats OmiCron as if it were a variety of forces.<br>
</li>
<li><code>omiCron.KnobLeftRed(); // returns a PVector reading for Magnitude, direction, velocity, etc</code></li>
<li><code>omiCron.lookup(KnobFoo); // returns an array of PVectors?????</code></li>
<li>[] make a version for SpiroLight</li>
</ul>
</li>
<li>[] rewrite the centerPiece_SpiroLight to include OmiCron

<ul>
<li>[] scale model using foam core or construction paper??</li>
<li>[] get all the inputs with stationary SpiroLight first Tiers 1-3</li>
</ul>
</li>
</ul>
      </section>

    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>